@import "../../errors.djinni"
@import "../amount.djinni"
@import "../../cosmos/addresses.djinni"

CosmosLikeAmount = record {
    amount: string;
    denom: string;
}

CosmosLikeContent = record {
    type: string;
    title: string;
    description: string;
}

CosmosLikeVoteOption = enum {
    Yes;
    No;
    NoWithVeto;
    Abstain;
}

CosmosLikeMsgSend = record {
    fromAddress: string;
    toAddress: string;
    amounts: list<CosmosLikeAmount>;
}

CosmosLikeMsgDelegate = record {
    delegatorAddress: string;
    validatorAddress: string;
    amount: CosmosLikeAmount;
}

CosmosLikeMsgUndelegate = record {
    delegatorAddress: string;
    validatorAddress: string;
    amount: CosmosLikeAmount;
}

CosmosLikeMsgRedelegate = record {
    delegatorAddress: string;
    validatorSourceAddress: string;
    validatorDestinationAddress: string;
    amount: CosmosLikeAmount;
}

CosmosLikeMsgSubmitProposal = record {
    content: CosmosLikeContent;
    proposer: string;
    initialDeposit: list<CosmosLikeAmount>;
}

CosmosLikeMsgVote = record {
    voter: string;
    proposalId: string;
    option: CosmosLikeVoteOption;
}

CosmosLikeMsgDeposit = record {
    depositor: string;
    proposalId: string;
    amounts: list<CosmosLikeAmount>;
}

CosmosLikeMsgWithdrawDelegationReward = record {
    delegatorAddress: string;
    validatorAddress: string;
}

CosmosLikeMsgType = enum {
    MsgSend;
    MsgDelegate;
    MsgUndelegate;
    MsgRedelegate;
    MsgSubmitProposal;
    MsgVote;
    MsgDeposit;
    MsgWithdrawDelegationReward;
    Unknown;
}

CosmosLikeMessage = interface +c {
    # Get type
    # @return CosmosLikeMsgType a message type
    const getMessageType(): CosmosLikeMsgType;

    # Get type
    # @return string a message type in string format
    const getRawMessageType(): string;

    # Wrap the given CosmosLikeMsgSend into a CosmosLikeMessage
    # @param msg The message you need to wrap.
    # @return CosmosLikeMessage A wrapped message.
    static wrapMsgSend(msg: CosmosLikeMsgSend): CosmosLikeMessage;
    # Unwrap a message to a CosmosLikeMsgSend
    # @param msg The message to unwrap
    # @return CosmosLikeMsgDelegate the unwrapped message
    static unwrapMsgSend(msg: CosmosLikeMessage): CosmosLikeMsgSend;


    # Wrap the given CosmosLikeMsgDelegate into a CosmosLikeMessage
    # @param msg The message you need to wrap.
    # @return CosmosLikeMessage A wrapped message.
    static wrapMsgDelegate(msg: CosmosLikeMsgDelegate): CosmosLikeMessage;
    # Unwrap a message to a CosmosLikeMsgDelegate
    # @param msg The message to unwrap
    # @return CosmosLikeMsgDelegate the unwrapped message
    static unwrapMsgDelegate(msg: CosmosLikeMessage): CosmosLikeMsgDelegate;

    # Wrap the given CosmosLikeMsgUndelegate into a CosmosLikeMessage
    # @param msg The message you need to wrap.
    # @return CosmosLikeMessage A wrapped message.
    static wrapMsgUndelegate(msg: CosmosLikeMsgUndelegate): CosmosLikeMessage;
    # Unwrap a message to a CosmosLikeMsgUndelegate
    # @param msg The message to unwrap
    # @return CosmosLikeMsgUndelegate the unwrapped message
    static unwrapMsgUndelegate(msg: CosmosLikeMessage): CosmosLikeMsgUndelegate;

    # Wrap the given CosmosLikeMsgRedelegate into a CosmosLikeMessage
    # @param msg The message you need to wrap.
    # @return CosmosLikeMessage A wrapped message.
    static wrapMsgRedelegate(msg: CosmosLikeMsgRedelegate): CosmosLikeMessage;
    # Unwrap a message to a CosmosLikeMsgRedelegate
    # @param msg The message to unwrap
    # @return CosmosLikeMsgRedelegate the unwrapped message
    static unwrapMsgRedelegate(msg: CosmosLikeMessage): CosmosLikeMsgRedelegate;

    # Wrap the given CosmosLikeMsgSubmitProposal into a CosmosLikeMessage
    # @param msg The message you need to wrap.
    # @return CosmosLikeMessage A wrapped message.
    static wrapMsgSubmitProposal(msg: CosmosLikeMsgSubmitProposal): CosmosLikeMessage;
    # Unwrap a message to a CosmosLikeMsgSubmitProposal
    # @param msg The message to unwrap
    # @return CosmosLikeMsgSubmitProposal the unwrapped message
    static unwrapMsgSubmitProposal(msg: CosmosLikeMessage): CosmosLikeMsgSubmitProposal;

    # Wrap the given CosmosLikeMsgVote into a CosmosLikeMessage
    # @param msg The message you need to wrap.
    # @return CosmosLikeMessage A wrapped message.
    static wrapMsgVote(msg: CosmosLikeMsgVote): CosmosLikeMessage;
    # Unwrap a message to a CosmosLikeMsgVote
    # @param msg The message to unwrap
    # @return CosmosLikeMsgVote the unwrapped message
    static unwrapMsgVote(msg: CosmosLikeMessage): CosmosLikeMsgVote;

    # Wrap the given CosmosLikeMsgDeposit into a CosmosLikeMessage
    # @param msg The message you need to wrap.
    # @return CosmosLikeMessage A wrapped message.
    static wrapMsgDeposit(msg: CosmosLikeMsgDeposit): CosmosLikeMessage;
    # Unwrap a message to a CosmosLikeMsgDeposit
    # @param msg The message to unwrap
    # @return CosmosLikeMsgDeposit the unwrapped message
    static unwrapMsgDeposit(msg: CosmosLikeMessage): CosmosLikeMsgDeposit;

    # Wrap the given CosmosLikeMsgWithdrawDelegationReward into a CosmosLikeMessage
    # @param msg The message you need to wrap.
    # @return CosmosLikeMessage A wrapped message.
    static wrapMsgWithdrawDelegationReward(msg: CosmosLikeMsgWithdrawDelegationReward): CosmosLikeMessage;
    # Unwrap a message to a CosmosLikeMsgWithdrawDelegationReward
    # @param msg The message to unwrap
    # @return CosmosLikeMsgWithdrawDelegationReward the unwrapped message
    static unwrapMsgWithdrawDelegationReward(msg: CosmosLikeMessage): CosmosLikeMsgWithdrawDelegationReward;
}

#Class representing a Cosmos transaction
CosmosLikeTransaction = interface +c {
	# Get the hash of the transaction.
	const getHash(): string;
	# Get Fee (in drop)
	const getFee(): Amount;
	# Serialize the transaction to its JSON format.
	serialize(): string;
    # Get the list of messages
    const getMessages(): list<CosmosLikeMessage>;
    # Get memo
    const getMemo(): string;
    # Set signature of transaction, when a signature is set serialize method gives back serialized Tx
	setSignature(rSignature: binary, sSignature: binary);
	setDERSignature(signature: binary);
	# Get the time when the transaction was issued or the time of the block including
	# this transaction
	const getDate(): date;
	# Get Signing public Key
	const getSigningPubKey(): binary;
	const getGas(): Amount;
}

#Class representing a Cosmos Operation
CosmosLikeOperation = interface +c {
	#Get operation's transaction
	#@return CosmosLikeTransaction object
	getTransaction(): CosmosLikeTransaction;

    # Get message which created this operation
    # @return CosmosLikeMessage object
    getMessage(): CosmosLikeMessage;
}

#Class representing Bitcoin block
CosmosLikeBlock = interface +c {
	#Hash of block
	#@return string representing hash of this block
	getHash(): string;
	#Height of block in blockchain
	#@return 64 bits integer, height of block
	getHeight(): i64;
	#Timestamp when block was mined
	#@return Date object, date when block was appended to blockchain
	getTime(): date;
}

CosmosLikeTransactionBuilder = interface +c {
    # Set memo
    # @param memo the memo to set
    setMemo(memo: string): CosmosLikeTransactionBuilder;

    # Set sequence
    # @param sequence The sequence to set
    setSequence(sequence: string): CosmosLikeTransactionBuilder;

    # Add a new message in the internal range of messages
    # @param msg a new message
    addMessage(msg: CosmosLikeMessage): CosmosLikeTransactionBuilder;

    # Set gas price
    # @param gas The gas to set
	setGas(gas: Amount): CosmosLikeTransactionBuilder;

    # Set fee
    # Here the fee represents the gas price multiplied by the gas used
    # @param fee The fee to set
    setFee(fee: Amount): CosmosLikeTransactionBuilder;

	# Build a transaction from the given builder parameters.
	build(callback: Callback<CosmosLikeTransaction>);

	# Creates a clone of this builder.
	# @return A copy of the current builder instance.
	clone(): CosmosLikeTransactionBuilder;

	# Reset the current instance to its initial state
	reset();

	static parseRawUnsignedTransaction(currency: Currency, rawTransaction: string): CosmosLikeTransaction;
	static parseRawSignedTransaction(currency: Currency, rawTransaction: string): CosmosLikeTransaction;
}

#Class representing a Cosmos account
CosmosLikeAccount = interface +c {
	broadcastRawTransaction(transaction: string, callback: Callback<string>);
	broadcastTransaction(transaction: CosmosLikeTransaction, callback: Callback<string>);
	buildTransaction(): CosmosLikeTransactionBuilder;
	# Get estimated gas limit to set so the transaction will succeed
	getEstimatedGasLimit(transaction: CosmosLikeTransaction, callback: Callback<BigInt>);
}

CosmosConfigurationDefaults = interface +c {
	const COSMOS_DEFAULT_API_ENDPOINT: string = "https://lcd.nylira.net/";
	const COSMOS_OBSERVER_WS_ENDPOINT: string = "";
}
